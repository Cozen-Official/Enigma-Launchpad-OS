#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEditorInternal;
using UnityEngine;

namespace Cozen
{
    public partial class EnigmaLaunchpadEditor : Editor
    {
        private SerializedProperty mochiHandlerProperty;
        private SerializedObject mochiHandlerObject;

        private SerializedProperty mochieMaterialStandard;
        private SerializedProperty mochieMaterialX;
        private SerializedProperty overlayTextures;
        private SerializedProperty overlayNames;
        private SerializedProperty outlineColors;
        private SerializedProperty outlineColorNames;
        private SerializedProperty mochieOutlineAuraLow;
        private SerializedProperty mochieOutlineThresholdLow;
        private SerializedProperty mochieOutlineSobelLow;
        private SerializedProperty mochieOutlineAuraNormal;
        private SerializedProperty mochieOutlineThresholdNormal;
        private SerializedProperty mochieOutlineSobelNormal;
        private SerializedProperty mochieOutlineAuraHigh;
        private SerializedProperty mochieOutlineThresholdHigh;
        private SerializedProperty mochieOutlineSobelHigh;
        private SerializedProperty mochieInvertStrength;
        private SerializedProperty mochieInvertPlusStrength;
        private SerializedProperty mochieShakeAmplitude;
        private SerializedProperty mochieBlurStrength;
        private SerializedProperty mochieDistortionStrength;
        private SerializedProperty mochieNoiseStrength;
        private SerializedProperty mochieScanLineStrength;
        private SerializedProperty mochieDepthBufferOpacity;
        private SerializedProperty mochieNormalMapOpacity;

        private ReorderableList overlayEntriesList;
        private ReorderableList outlineColorEntriesList;
        private readonly List<bool> autoGeneratedOutlineNameFlags = new List<bool>();
        private readonly List<bool> autoGeneratedOverlayNameFlags = new List<bool>();

        private bool mochieConfigurationExpanded = true;
        private bool mochieOutlineListExpanded = true;
        private bool mochieOverlayListExpanded = true;

        private bool mochieShaderStandardAvailable;
        private bool mochieShaderXAvailable;
        private static readonly GUIContent ResetMochieDefaultsContent = new GUIContent("\u21BA", "Reset Mochie sliders to their default values");

        // Format constants for auto-generated hex color names (e.g., "Color #RRGGBB")
        private const string HexColorNamePrefix = "Color #";
        // Note: Can't use HexColorNamePrefix.Length in const expression, so hardcoding 8 + 6 = 14
        private const int HexColorNameLength = 8 + 6; // "Color #" (8 chars) + 6 hex digits for RGB
        
        // Fixed number of overlay slots in Mochie folder (overlay buttons 0-2, scan buttons 3-5)
        private const int OverlaySlotCount = 3;

        private SerializedProperty shaderRenderer
        {
            get
            {
                if (mochiHandlerObject != null)
                {
                    return mochiHandlerObject.FindProperty("shaderRenderer");
                }
                return null;
            }
        }

        private void BindMochieHandlerSerializedObject()
        {
            mochiHandlerObject = null;

            mochieMaterialStandard = null;
            mochieMaterialX = null;
            overlayTextures = null;
            overlayNames = null;
            outlineColors = null;
            outlineColorNames = null;
            mochieOutlineAuraLow = null;
            mochieOutlineThresholdLow = null;
            mochieOutlineSobelLow = null;
            mochieOutlineAuraNormal = null;
            mochieOutlineThresholdNormal = null;
            mochieOutlineSobelNormal = null;
            mochieOutlineAuraHigh = null;
            mochieOutlineThresholdHigh = null;
            mochieOutlineSobelHigh = null;
            mochieInvertStrength = null;
            mochieInvertPlusStrength = null;
            mochieShakeAmplitude = null;
            mochieBlurStrength = null;
            mochieDistortionStrength = null;
            mochieNoiseStrength = null;
            mochieScanLineStrength = null;
            mochieDepthBufferOpacity = null;
            mochieNormalMapOpacity = null;

            // Material properties are now on the main EnigmaLaunchpad object, not the handler
            mochieMaterialStandard = mochieMaterialStandardProperty;
            mochieMaterialX = mochieMaterialXProperty;

            if (mochiHandlerProperty == null || mochiHandlerProperty.objectReferenceValue == null)
            {
                return;
            }

            mochiHandlerObject = new SerializedObject(mochiHandlerProperty.objectReferenceValue);

            overlayTextures = mochiHandlerObject.FindProperty("overlayTextures");
            overlayNames = mochiHandlerObject.FindProperty("overlayNames");
            outlineColors = mochiHandlerObject.FindProperty("outlineColors");
            outlineColorNames = mochiHandlerObject.FindProperty("outlineColorNames");
            mochieOutlineAuraLow = mochiHandlerObject.FindProperty("mochieOutlineAuraLow");
            mochieOutlineThresholdLow = mochiHandlerObject.FindProperty("mochieOutlineThresholdLow");
            mochieOutlineSobelLow = mochiHandlerObject.FindProperty("mochieOutlineSobelLow");
            mochieOutlineAuraNormal = mochiHandlerObject.FindProperty("mochieOutlineAuraNormal");
            mochieOutlineThresholdNormal = mochiHandlerObject.FindProperty("mochieOutlineThresholdNormal");
            mochieOutlineSobelNormal = mochiHandlerObject.FindProperty("mochieOutlineSobelNormal");
            mochieOutlineAuraHigh = mochiHandlerObject.FindProperty("mochieOutlineAuraHigh");
            mochieOutlineThresholdHigh = mochiHandlerObject.FindProperty("mochieOutlineThresholdHigh");
            mochieOutlineSobelHigh = mochiHandlerObject.FindProperty("mochieOutlineSobelHigh");
            mochieInvertStrength = mochiHandlerObject.FindProperty("mochieInvertStrength");
            mochieInvertPlusStrength = mochiHandlerObject.FindProperty("mochieInvertPlusStrength");
            mochieShakeAmplitude = mochiHandlerObject.FindProperty("mochieShakeAmplitude");
            mochieBlurStrength = mochiHandlerObject.FindProperty("mochieBlurStrength");
            mochieDistortionStrength = mochiHandlerObject.FindProperty("mochieDistortionStrength");
            mochieNoiseStrength = mochiHandlerObject.FindProperty("mochieNoiseStrength");
            mochieScanLineStrength = mochiHandlerObject.FindProperty("mochieScanLineStrength");
            mochieDepthBufferOpacity = mochiHandlerObject.FindProperty("mochieDepthBufferOpacity");
            mochieNormalMapOpacity = mochiHandlerObject.FindProperty("mochieNormalMapOpacity");
        }

        private void CacheMochieShaderAvailability()
        {
            mochieShaderStandardAvailable = ShaderAssetExists("Mochie/Screen FX");
            mochieShaderXAvailable = ShaderAssetExists("Mochie/Screen FX X");

            if (mochiHandlerObject == null)
            {
                return;
            }

            SerializedProperty standardDetected = mochiHandlerObject.FindProperty("mochieShaderStandardDetected");
            SerializedProperty xDetected = mochiHandlerObject.FindProperty("mochieShaderXDetected");
            SerializedProperty detectionInitialized = mochiHandlerObject.FindProperty("mochieShaderDetectionInitialized");

            if (standardDetected != null) standardDetected.boolValue = mochieShaderStandardAvailable;
            if (xDetected != null) xDetected.boolValue = mochieShaderXAvailable;
            if (detectionInitialized != null) detectionInitialized.boolValue = true;

            mochiHandlerObject.ApplyModifiedPropertiesWithoutUndo();
            mochiHandlerObject.Update();
        }

        private void GetMochieMaterialStatus(out bool hasValidStandard, out bool hasValidX)
        {
            hasValidStandard = IsValidStandardMochieMaterial(mochieMaterialStandard?.objectReferenceValue as Material);
            hasValidX = IsValidXMochieMaterial(mochieMaterialX?.objectReferenceValue as Material);
        }

        private static bool IsValidStandardMochieMaterial(Material material)
        {
            return IsMochieShader(material, "Mochie/Screen FX") && !IsMochieShader(material, "Mochie/Screen FX X");
        }

        private static bool IsValidXMochieMaterial(Material material)
        {
            return IsMochieShader(material, "Mochie/Screen FX X");
        }

        private static bool IsMochieShader(Material material, string shaderName)
        {
            if (material == null || material.shader == null) return false;
            string currentShaderName = material.shader.name;
            if (string.IsNullOrEmpty(currentShaderName)) return false;
            return currentShaderName.IndexOf(shaderName, StringComparison.OrdinalIgnoreCase) >= 0;
        }

        private void EnsureMochieHandlerParity()
        {
            EnigmaLaunchpad launchpad = target as EnigmaLaunchpad;
            if (launchpad == null || mochiHandlerProperty == null)
            {
                mochiHandlerObject = null;
                return;
            }

            int mochiFolderIndex = GetFolderIndexForType(ToggleFolderType.Mochie);
            MochieHandler handler = mochiHandlerProperty.objectReferenceValue as MochieHandler;
            string expectedName = GetExpectedMochieHandlerName(mochiFolderIndex);

            MochieHandler[] existingHandlers = launchpad.GetComponentsInChildren<MochieHandler>(true);
            if (mochiFolderIndex < 0)
            {
                foreach (MochieHandler existing in existingHandlers)
                {
                    if (existing != null)
                    {
                        Undo.DestroyObjectImmediate(existing.gameObject);
                    }
                }

                mochiHandlerProperty.objectReferenceValue = null;
                mochiHandlerObject = null;
                return;
            }

            Transform foldersTransform = GetFoldersTransform(launchpad);
            foreach (MochieHandler existing in existingHandlers)
            {
                if (handler == null)
                {
                    handler = existing;
                }
                else if (existing != null && existing != handler)
                {
                    Undo.DestroyObjectImmediate(existing.gameObject);
                }
            }

            if (handler == null)
            {
                GameObject handlerObject = new GameObject(expectedName);
                Undo.RegisterCreatedObjectUndo(handlerObject, "Create MochieHandler");
                handlerObject.transform.SetParent(foldersTransform);
                handlerObject.hideFlags = HandlerHideFlags;

                handler = handlerObject.AddComponent<MochieHandler>();
            }

            Undo.RecordObject(handler, "Configure MochieHandler");
            handler.launchpad = launchpad;
            handler.folderIndex = mochiFolderIndex;
            handler.transform.SetParent(foldersTransform);
            if (handler.gameObject.name != expectedName)
            {
                Undo.RecordObject(handler.gameObject, "Rename MochieHandler");
                handler.gameObject.name = expectedName;
            }
            if (handler.gameObject.hideFlags != HandlerHideFlags)
            {
                handler.gameObject.hideFlags = HandlerHideFlags;
            }

            mochiHandlerProperty.objectReferenceValue = handler;
        }

        private string GetExpectedMochieHandlerName(int folderIndex)
        {
            string folderName = GetResolvedFolderName(folderIndex);
            return $"MochieHandler_{folderName}";
        }

        private void EnsureOutlineColorArrayParity()
        {
            if (outlineColors == null && outlineColorNames == null) return;

            int targetSize = Mathf.Max(
                outlineColors != null ? outlineColors.arraySize : 0,
                outlineColorNames != null ? outlineColorNames.arraySize : 0);

            EnsureArraySize(outlineColors, targetSize, prop =>
            {
                if (prop != null)
                {
                    prop.colorValue = Color.white;
                }
            });

            EnsureArraySize(outlineColorNames, targetSize, prop =>
            {
                if (prop != null)
                {
                    prop.stringValue = string.Empty;
                }
            });

            EnsureAutoGeneratedNameFlags();
        }

        private static bool SerializedArrayHasIndex(SerializedProperty array, int index)
        {
            return array != null && index >= 0 && index < array.arraySize;
        }

        private void EnsureAutoGeneratedNameFlags()
        {
            int colorCount = outlineColors != null ? Mathf.Max(0, outlineColors.arraySize) : 0;
            int nameCount = outlineColorNames != null ? Mathf.Max(0, outlineColorNames.arraySize) : 0;
            int targetSize = Mathf.Max(colorCount, nameCount);

            while (autoGeneratedOutlineNameFlags.Count < targetSize)
            {
                autoGeneratedOutlineNameFlags.Add(false);
            }

            while (autoGeneratedOutlineNameFlags.Count > targetSize)
            {
                autoGeneratedOutlineNameFlags.RemoveAt(autoGeneratedOutlineNameFlags.Count - 1);
            }
        }

        private bool IsAutoGeneratedOutlineName(int index)
        {
            return index >= 0 && index < autoGeneratedOutlineNameFlags.Count && autoGeneratedOutlineNameFlags[index];
        }

        private void SetAutoGeneratedOutlineName(int index, bool value)
        {
            EnsureAutoGeneratedNameFlags();
            if (index < 0 || index >= autoGeneratedOutlineNameFlags.Count) return;
            autoGeneratedOutlineNameFlags[index] = value;
        }

        private void InsertAutoGeneratedOutlineNameFlag(int index, bool value)
        {
            EnsureAutoGeneratedNameFlags();
            index = Mathf.Clamp(index, 0, autoGeneratedOutlineNameFlags.Count);
            autoGeneratedOutlineNameFlags.Insert(index, value);
        }

        private void RemoveAutoGeneratedOutlineNameFlag(int index)
        {
            if (index < 0 || index >= autoGeneratedOutlineNameFlags.Count) return;
            autoGeneratedOutlineNameFlags.RemoveAt(index);
        }

        private void MoveAutoGeneratedOutlineNameFlag(int oldIndex, int newIndex)
        {
            if (oldIndex < 0 || oldIndex >= autoGeneratedOutlineNameFlags.Count) return;

            bool flag = autoGeneratedOutlineNameFlags[oldIndex];
            autoGeneratedOutlineNameFlags.RemoveAt(oldIndex);
            int targetIndex = Mathf.Clamp(newIndex, 0, autoGeneratedOutlineNameFlags.Count);
            autoGeneratedOutlineNameFlags.Insert(targetIndex, flag);
        }

        private void BuildOutlineColorEntriesList()
        {
            if (outlineColors == null || outlineColorNames == null)
            {
                outlineColorEntriesList = null;
                return;
            }

            EnsureAutoGeneratedNameFlags();

            outlineColorEntriesList = new ReorderableList(mochiHandlerObject, outlineColors, true, true, true, true)
            {
                drawHeaderCallback = rect => EditorGUI.LabelField(rect, "Outline Colors"),
                drawElementCallback = (rect, index, active, focused) =>
                {
                    SerializedProperty colorProp = outlineColors.GetArrayElementAtIndex(index);
                    SerializedProperty nameProp = outlineColorNames.GetArrayElementAtIndex(index);

                    float lineHeight = EditorGUIUtility.singleLineHeight;
                    float spacing = EditorGUIUtility.standardVerticalSpacing;

                    string existingName = nameProp.stringValue;

                    Rect colorRect = new Rect(rect.x, rect.y, rect.width, lineHeight);
                    EditorGUI.BeginChangeCheck();
                    EditorGUI.PropertyField(colorRect, colorProp, new GUIContent("Color"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        AutoPopulateOutlineColorName(index, colorProp, nameProp, existingName);
                    }

                    Rect nameRect = new Rect(rect.x, rect.y + lineHeight + spacing, rect.width, lineHeight);
                    EditorGUI.BeginChangeCheck();
                    EditorGUI.PropertyField(nameRect, nameProp, new GUIContent("Name"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        SetAutoGeneratedOutlineName(index, false);
                    }
                },
                elementHeightCallback = _ =>
                    EditorGUIUtility.singleLineHeight * 2f + EditorGUIUtility.standardVerticalSpacing * 2f,
                onAddCallback = list =>
                {
                    int newIndex = outlineColors.arraySize;
                    outlineColors.InsertArrayElementAtIndex(newIndex);
                    outlineColorNames.InsertArrayElementAtIndex(newIndex);
                    InsertAutoGeneratedOutlineNameFlag(newIndex, true);

                    SerializedProperty colorProp = outlineColors.GetArrayElementAtIndex(newIndex);
                    if (colorProp != null) colorProp.colorValue = Color.white;

                    SerializedProperty nameProp = outlineColorNames.GetArrayElementAtIndex(newIndex);
                    if (nameProp != null) nameProp.stringValue = string.Empty;

                    list.index = newIndex;
                },
                onRemoveCallback = list =>
                {
                    int index = list.index;
                    if (index < 0 || index >= outlineColors.arraySize) return;

                    outlineColors.DeleteArrayElementAtIndex(index);
                    outlineColorNames.DeleteArrayElementAtIndex(index);
                    RemoveAutoGeneratedOutlineNameFlag(index);

                    list.index = outlineColors.arraySize == 0
                        ? -1
                        : Mathf.Clamp(index, 0, outlineColors.arraySize - 1);
                }
            };

            outlineColorEntriesList.onReorderCallbackWithDetails = (list, oldIndex, newIndex) =>
            {
                outlineColors.MoveArrayElement(oldIndex, newIndex);
                outlineColorNames.MoveArrayElement(oldIndex, newIndex);
                MoveAutoGeneratedOutlineNameFlag(oldIndex, newIndex);
            };
        }

        private void EnsureOutlineListReady()
        {
            if (outlineColors == null || outlineColorNames == null)
            {
                outlineColorEntriesList = null;
                return;
            }

            EnsureOutlineColorArrayParity();
            EnsureAutoGeneratedNameFlags();

            if (outlineColorEntriesList == null || outlineColorEntriesList.count != outlineColors.arraySize)
            {
                BuildOutlineColorEntriesList();
            }
        }

        private void AutoPopulateOutlineColorName(int index, SerializedProperty colorProp, SerializedProperty nameProp, string existingName)
        {
            if (colorProp == null || nameProp == null) return;

            // If the user already entered a custom name (not auto-generated), don't overwrite it
            bool looksAutoGenerated = LooksLikeAutoGeneratedColorName(existingName);
            if (!string.IsNullOrWhiteSpace(existingName) && !IsAutoGeneratedOutlineName(index) && !looksAutoGenerated)
            {
                return;
            }

            string matchedName = GetMatchedColorName(colorProp.colorValue);
            nameProp.stringValue = matchedName;
            SetAutoGeneratedOutlineName(index, true);
        }

        private void EnsureOverlayArrayParity()
        {
            if (overlayTextures == null && overlayNames == null) return;

            // Always ensure exactly OverlaySlotCount (3) elements for both arrays
            // This matches the fixed number of overlay/scan buttons in the Mochie folder layout
            EnsureArraySize(overlayTextures, OverlaySlotCount, prop =>
            {
                if (prop != null)
                {
                    prop.objectReferenceValue = null;
                }
            });

            EnsureArraySize(overlayNames, OverlaySlotCount, prop =>
            {
                if (prop != null)
                {
                    prop.stringValue = string.Empty;
                }
            });
        }

        private void EnsureOverlayListReady()
        {
            if (overlayTextures == null || overlayNames == null)
            {
                overlayEntriesList = null;
                return;
            }

            EnsureOverlayArrayParity();
            EnsureAutoGeneratedOverlayNameFlags();

            if (overlayEntriesList == null || overlayEntriesList.count != overlayTextures.arraySize)
            {
                BuildOverlayEntriesList();
            }
        }

        private void EnsureAutoGeneratedOverlayNameFlags()
        {
            int textureCount = overlayTextures != null ? Mathf.Max(0, overlayTextures.arraySize) : 0;
            int nameCount = overlayNames != null ? Mathf.Max(0, overlayNames.arraySize) : 0;
            int targetSize = Mathf.Max(textureCount, nameCount);

            while (autoGeneratedOverlayNameFlags.Count < targetSize)
            {
                autoGeneratedOverlayNameFlags.Add(false);
            }

            while (autoGeneratedOverlayNameFlags.Count > targetSize)
            {
                autoGeneratedOverlayNameFlags.RemoveAt(autoGeneratedOverlayNameFlags.Count - 1);
            }
        }

        private bool IsAutoGeneratedOverlayName(int index)
        {
            return index >= 0 && index < autoGeneratedOverlayNameFlags.Count && autoGeneratedOverlayNameFlags[index];
        }

        private void SetAutoGeneratedOverlayName(int index, bool value)
        {
            EnsureAutoGeneratedOverlayNameFlags();
            if (index < 0 || index >= autoGeneratedOverlayNameFlags.Count) return;
            autoGeneratedOverlayNameFlags[index] = value;
        }

        private void BuildOverlayEntriesList()
        {
            if (overlayTextures == null || overlayNames == null)
            {
                overlayEntriesList = null;
                return;
            }

            EnsureOverlayArrayParity();
            EnsureAutoGeneratedOverlayNameFlags();

            // Create a fixed list without add/remove/reorder capabilities
            // The overlay array is fixed at OverlaySlotCount (3) elements to match the launchpad layout
            overlayEntriesList = new ReorderableList(mochiHandlerObject, overlayTextures, false, true, false, false)
            {
                drawHeaderCallback = rect => EditorGUI.LabelField(rect, $"Screen Overlays ({OverlaySlotCount} Slots)"),
                drawElementCallback = (rect, index, active, focused) =>
                {
                    SerializedProperty textureProp = overlayTextures.GetArrayElementAtIndex(index);
                    SerializedProperty nameProp = overlayNames.GetArrayElementAtIndex(index);

                    float lineHeight = EditorGUIUtility.singleLineHeight;
                    float spacing = EditorGUIUtility.standardVerticalSpacing;

                    // Show slot number in the label
                    Rect textureRect = new Rect(rect.x, rect.y, rect.width, lineHeight);
                    EditorGUI.BeginChangeCheck();
                    EditorGUI.PropertyField(textureRect, textureProp, new GUIContent($"Slot {index + 1} Texture"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        AutoPopulateOverlayName(index, textureProp, nameProp);
                    }

                    Rect nameRect = new Rect(rect.x, rect.y + lineHeight + spacing, rect.width, lineHeight);
                    EditorGUI.BeginChangeCheck();
                    EditorGUI.PropertyField(nameRect, nameProp, new GUIContent($"Slot {index + 1} Name"));
                    if (EditorGUI.EndChangeCheck())
                    {
                        SetAutoGeneratedOverlayName(index, false);
                    }
                },
                elementHeightCallback = _ =>
                    EditorGUIUtility.singleLineHeight * 2f + EditorGUIUtility.standardVerticalSpacing * 2f
            };
            // Note: onAddCallback, onRemoveCallback, and onReorderCallbackWithDetails are not set
            // because the list is fixed and does not support add/remove/reorder
        }

        private void AutoPopulateOverlayName(int index, SerializedProperty textureProp, SerializedProperty nameProp)
        {
            if (textureProp == null || nameProp == null) return;

            string existingName = nameProp.stringValue;
            if (!string.IsNullOrWhiteSpace(existingName) && !IsAutoGeneratedOverlayName(index))
            {
                Texture currentTexture = textureProp.objectReferenceValue as Texture;
                if (currentTexture != null)
                {
                    return;
                }
            }

            Texture texture = textureProp.objectReferenceValue as Texture;
            if (texture == null)
            {
                if (IsAutoGeneratedOverlayName(index))
                {
                    nameProp.stringValue = string.Empty;
                    SetAutoGeneratedOverlayName(index, false);
                }
                return;
            }

            string assetPath = AssetDatabase.GetAssetPath(texture);
            string baseName = !string.IsNullOrEmpty(assetPath)
                ? Path.GetFileNameWithoutExtension(assetPath)
                : texture.name;

            if (string.IsNullOrWhiteSpace(baseName))
            {
                return;
            }

            nameProp.stringValue = baseName;
            SetAutoGeneratedOverlayName(index, true);
        }

        private bool DrawMochieFolderSection(
            ToggleFolderType folderType,
            SerializedProperty exclProp,
            SerializedProperty rendererProp,
            SerializedProperty countProp,
            ref bool structural)
        {
            if (folderType != ToggleFolderType.Mochie)
            {
                return false;
            }

            if (exclProp.boolValue)
            {
                exclProp.boolValue = false;
            }
            if (rendererProp != null && rendererProp.isArray && rendererProp.arraySize > 0)
            {
                rendererProp.arraySize = 0;
            }

            GUILayout.Space(6);
            DrawMochieConfiguration();
            GUILayout.Space(6);

            if (countProp.intValue != 0)
            {
                countProp.intValue = 0;
                structural = true;
            }

            EditorGUI.indentLevel--;
            return true;
        }

        private void DrawMochieConfiguration()
        {
            if (shaderRenderer != null)
            {
                EditorGUILayout.PropertyField(shaderRenderer, new GUIContent("Target Renderer"));
            }

            using (new EditorGUILayout.HorizontalScope())
            {
                bool updatedConfigurationExpanded = EditorGUILayout.Foldout(
                    mochieConfigurationExpanded,
                    new GUIContent("Mochie Configuration"),
                    true);

                if (updatedConfigurationExpanded != mochieConfigurationExpanded)
                {
                    mochieConfigurationExpanded = updatedConfigurationExpanded;
                    SavePersistedFoldoutStates();
                }

                GUILayout.FlexibleSpace();

                if (GUILayout.Button(ResetMochieDefaultsContent, GUILayout.Width(EditorGUIUtility.singleLineHeight + 10f)))
                {
                    ResetMochieSlidersToDefaults();
                }
            }

            if (mochieConfigurationExpanded)
            {
                GetMochieMaterialStatus(out bool standardMaterialAssigned, out bool xMaterialAssigned);
                bool anyMaterialAssigned = standardMaterialAssigned || xMaterialAssigned;
                bool hasStandardShader = mochieShaderStandardAvailable || (mochieMaterialStandard?.objectReferenceValue != null);
                bool hasXShader = mochieShaderXAvailable || (mochieMaterialX?.objectReferenceValue != null);

                if (!hasStandardShader && !hasXShader)
                {
                    EditorGUILayout.HelpBox(MochieHandler.MochieScreenFxMissingMessage, MessageType.Info);
                }
                else if (!anyMaterialAssigned)
                {
                    EditorGUILayout.HelpBox(
                        "Assign a valid Mochie material in Internal References to configure Mochie features.",
                        MessageType.Info);
                }
                else if (hasStandardShader && !hasXShader)
                {
                    EditorGUILayout.HelpBox(MochieHandler.MochieScreenFxUpgradeMessage, MessageType.Info);
                }

                DrawMochieEffectControls(anyMaterialAssigned, hasStandardShader, hasXShader);
            }
        }

        private void DrawMochieEffectControls(bool anyMaterialAssigned, bool hasStandardShader, bool hasXShader)
        {
            using (new EditorGUI.DisabledScope(!anyMaterialAssigned))
            {
                EditorGUILayout.Space(2f);

                // Material Settings section - Min/Max Range and Render Queue
                EditorGUILayout.LabelField("Material Settings", EditorStyles.boldLabel);
                DrawMochieMaterialSettings();
                EditorGUILayout.Space(6f);

                EditorGUILayout.LabelField("Outline Settings", EditorStyles.boldLabel);
                EditorGUILayout.LabelField("Select outline settings for each Mode level (Low/Normal/High)");
                EditorGUILayout.Space(2f);

                EditorGUILayout.LabelField("Mode: Low", EditorStyles.boldLabel);
                DrawMochieSlider(mochieOutlineAuraLow, MochieHandler.MochieAuraStrengthMin, MochieHandler.MochieAuraStrengthMax, "Low Aura Strength");
                DrawMochieSlider(mochieOutlineThresholdLow, MochieHandler.MochieOutlineThresholdMin, MochieHandler.MochieOutlineThresholdMax, "Low Outline Threshold");
                DrawMochieSlider(mochieOutlineSobelLow, MochieHandler.MochieSobelOpacityMin, MochieHandler.MochieSobelOpacityMax, "Low Sobel Opacity");

                EditorGUILayout.Space(2f);
                EditorGUILayout.LabelField("Mode: Normal", EditorStyles.boldLabel);
                DrawMochieSlider(mochieOutlineAuraNormal, MochieHandler.MochieAuraStrengthMin, MochieHandler.MochieAuraStrengthMax, "Normal Aura Strength");
                DrawMochieSlider(mochieOutlineThresholdNormal, MochieHandler.MochieOutlineThresholdMin, MochieHandler.MochieOutlineThresholdMax, "Normal Outline Threshold");
                DrawMochieSlider(mochieOutlineSobelNormal, MochieHandler.MochieSobelOpacityMin, MochieHandler.MochieSobelOpacityMax, "Normal Sobel Opacity");

                EditorGUILayout.Space(2f);
                EditorGUILayout.LabelField("Mode: High", EditorStyles.boldLabel);
                DrawMochieSlider(mochieOutlineAuraHigh, MochieHandler.MochieAuraStrengthMin, MochieHandler.MochieAuraStrengthMax, "High Aura Strength");
                DrawMochieSlider(mochieOutlineThresholdHigh, MochieHandler.MochieOutlineThresholdMin, MochieHandler.MochieOutlineThresholdMax, "High Outline Threshold");
                DrawMochieSlider(mochieOutlineSobelHigh, MochieHandler.MochieSobelOpacityMin, MochieHandler.MochieSobelOpacityMax, "High Sobel Opacity");

                DrawOutlineColorsFoldout(anyMaterialAssigned, hasStandardShader);

                EditorGUILayout.Space(6f);
                EditorGUILayout.LabelField("FX Settings", EditorStyles.boldLabel);
                DrawMochieSlider(mochieInvertStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Invert Strength");
                DrawMochieSlider(mochieInvertPlusStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Invert+ Strength");
                DrawMochieSlider(mochieShakeAmplitude, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Shake Amplitude");
                DrawMochieSlider(mochieBlurStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Blur Strength");
                DrawMochieSlider(mochieDistortionStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Distortion Strength");
                DrawMochieSlider(mochieNoiseStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Noise Strength");
                DrawMochieSlider(mochieScanLineStrength, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Scan Line Strength");

                bool hasDepthOrNormal = hasXShader || (mochieMaterialX?.objectReferenceValue as Material) != null;
                using (new EditorGUI.DisabledScope(!hasDepthOrNormal))
                {
                    DrawMochieSlider(mochieDepthBufferOpacity, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Depth Buffer Opacity");
                    DrawMochieSlider(mochieNormalMapOpacity, MochieHandler.MochieEffectStrengthMin, MochieHandler.MochieEffectStrengthMax, "Normal Map Opacity");
                }

                DrawOverlayFoldout(anyMaterialAssigned, hasStandardShader, hasXShader);
            }
        }

        private void DrawMochieSlider(SerializedProperty property, float min, float max, string label)
        {
            if (property == null)
            {
                EditorGUILayout.HelpBox($"Missing property for {label}.", MessageType.Error);
                return;
            }

            EditorGUILayout.PropertyField(property, new GUIContent(label));
            property.floatValue = Mathf.Clamp(property.floatValue, min, max);
        }

        // Default values for Mochie material settings (matches shader defaults)
        private const float MochieMinRangeDefault = 8f;
        private const float MochieMaxRangeDefault = 15f;
        private const int MochieRenderQueueDefault = 3998;

        private void DrawMochieMaterialSettings()
        {
            Material standardMat = mochieMaterialStandard?.objectReferenceValue as Material;
            Material xMat = mochieMaterialX?.objectReferenceValue as Material;

            // Get current values from the first available material
            // Priority: X material over Standard since X has more features and is the preferred variant
            Material sourceMat = xMat ?? standardMat;
            float currentMinRange = MochieMinRangeDefault;
            float currentMaxRange = MochieMaxRangeDefault;
            int currentRenderQueue = MochieRenderQueueDefault;

            if (sourceMat != null)
            {
                if (sourceMat.HasProperty("_MinRange"))
                    currentMinRange = sourceMat.GetFloat("_MinRange");
                if (sourceMat.HasProperty("_MaxRange"))
                    currentMaxRange = sourceMat.GetFloat("_MaxRange");
                currentRenderQueue = sourceMat.renderQueue;
            }

            EditorGUI.BeginChangeCheck();

            float newMinRange = EditorGUILayout.FloatField(new GUIContent("Min Range", "Minimum falloff distance for Mochie effects"), currentMinRange);
            float newMaxRange = EditorGUILayout.FloatField(new GUIContent("Max Range", "Maximum falloff distance for Mochie effects"), currentMaxRange);
            int newRenderQueue = EditorGUILayout.IntField(new GUIContent("Render Queue", "Render queue for Mochie materials (default: 3998)"), currentRenderQueue);

            // Validate Min Range < Max Range
            if (newMinRange >= newMaxRange)
            {
                EditorGUILayout.HelpBox("Min Range should be less than Max Range for proper falloff behavior.", MessageType.Warning);
            }

            // Validate Render Queue range (Unity valid range is 0-5000)
            newRenderQueue = Mathf.Clamp(newRenderQueue, 0, 5000);

            if (EditorGUI.EndChangeCheck())
            {
                ApplyMochieMaterialSettings(newMinRange, newMaxRange, newRenderQueue);
            }
        }

        private void ApplyMochieMaterialSettings(float minRange, float maxRange, int renderQueue)
        {
            Material standardMat = mochieMaterialStandard?.objectReferenceValue as Material;
            Material xMat = mochieMaterialX?.objectReferenceValue as Material;

            // Apply settings to both materials
            if (standardMat != null)
            {
                Undo.RecordObject(standardMat, "Update Mochie Material Settings");
                if (standardMat.HasProperty("_MinRange"))
                    standardMat.SetFloat("_MinRange", minRange);
                if (standardMat.HasProperty("_MaxRange"))
                    standardMat.SetFloat("_MaxRange", maxRange);
                standardMat.renderQueue = renderQueue;
                EditorUtility.SetDirty(standardMat);
            }

            if (xMat != null)
            {
                Undo.RecordObject(xMat, "Update Mochie Material Settings");
                if (xMat.HasProperty("_MinRange"))
                    xMat.SetFloat("_MinRange", minRange);
                if (xMat.HasProperty("_MaxRange"))
                    xMat.SetFloat("_MaxRange", maxRange);
                xMat.renderQueue = renderQueue;
                EditorUtility.SetDirty(xMat);
            }
        }

        private void DrawOutlineColorsFoldout(bool anyMaterialAssigned, bool hasStandardShader)
        {
            bool updatedOutlineExpanded = EditorGUILayout.Foldout(mochieOutlineListExpanded, "Outline Colors", true);
            if (updatedOutlineExpanded != mochieOutlineListExpanded)
            {
                mochieOutlineListExpanded = updatedOutlineExpanded;
                SavePersistedFoldoutStates();
            }
            if (mochieOutlineListExpanded)
            {
                if (!anyMaterialAssigned)
                {
                    EditorGUILayout.HelpBox(
                        "Assign a valid Mochie material in Internal References to edit outline colors or overlays.",
                        MessageType.Info);
                }

                EnsureOutlineListReady();

                using (new EditorGUI.DisabledScope(!anyMaterialAssigned || !hasStandardShader))
                {
                    outlineColorEntriesList?.DoLayoutList();
                }
            }
        }

        private void DrawOverlayFoldout(bool anyMaterialAssigned, bool hasStandardShader, bool hasXShader)
        {
            bool updatedOverlayExpanded = EditorGUILayout.Foldout(mochieOverlayListExpanded, "Screen Overlays", true);
            if (updatedOverlayExpanded != mochieOverlayListExpanded)
            {
                mochieOverlayListExpanded = updatedOverlayExpanded;
                SavePersistedFoldoutStates();
            }
            if (mochieOverlayListExpanded)
            {
                EnsureOverlayArrayParity();
                EnsureOverlayListReady();
                using (new EditorGUI.DisabledScope(!anyMaterialAssigned || (!hasStandardShader && !hasXShader)))
                {
                    overlayEntriesList?.DoLayoutList();
                }
            }
        }

        private void ResetMochieSlidersToDefaults()
        {
            Undo.RecordObjects(targets, "Reset Mochie Defaults");

            SetFloatProperty(mochieOutlineAuraLow, MochieHandler.MochieOutlineAuraLowDefault);
            SetFloatProperty(mochieOutlineThresholdLow, MochieHandler.MochieOutlineThresholdLowDefault);
            SetFloatProperty(mochieOutlineSobelLow, MochieHandler.MochieOutlineSobelLowDefault);
            SetFloatProperty(mochieOutlineAuraNormal, MochieHandler.MochieOutlineAuraNormalDefault);
            SetFloatProperty(mochieOutlineThresholdNormal, MochieHandler.MochieOutlineThresholdNormalDefault);
            SetFloatProperty(mochieOutlineSobelNormal, MochieHandler.MochieOutlineSobelNormalDefault);
            SetFloatProperty(mochieOutlineAuraHigh, MochieHandler.MochieOutlineAuraHighDefault);
            SetFloatProperty(mochieOutlineThresholdHigh, MochieHandler.MochieOutlineThresholdHighDefault);
            SetFloatProperty(mochieOutlineSobelHigh, MochieHandler.MochieOutlineSobelHighDefault);
            SetFloatProperty(mochieInvertStrength, MochieHandler.MochieInvertStrengthDefault);
            SetFloatProperty(mochieInvertPlusStrength, MochieHandler.MochieInvertPlusStrengthDefault);
            SetFloatProperty(mochieShakeAmplitude, MochieHandler.MochieShakeAmplitudeDefault);
            SetFloatProperty(mochieBlurStrength, MochieHandler.MochieBlurStrengthDefault);
            SetFloatProperty(mochieDistortionStrength, MochieHandler.MochieDistortionStrengthDefault);
            SetFloatProperty(mochieNoiseStrength, MochieHandler.MochieNoiseStrengthDefault);
            SetFloatProperty(mochieScanLineStrength, MochieHandler.MochieScanLineStrengthDefault);
            SetFloatProperty(mochieDepthBufferOpacity, MochieHandler.MochieDepthBufferOpacityDefault);
            SetFloatProperty(mochieNormalMapOpacity, MochieHandler.MochieNormalMapOpacityDefault);
        }

        // Automatically set the Mochie layout flag based on assigned materials
        // Priority: If X material is assigned and valid, use X layout; otherwise use Standard layout
        private void SetMochieLayoutFlag()
        {
            if (mochiHandlerObject == null) return;

            // Check which materials are assigned and set layout flag accordingly
            Material standardMat = mochieMaterialStandard?.objectReferenceValue as Material;
            Material xMat = mochieMaterialX?.objectReferenceValue as Material;

            // Determine if we should use SFX X layout
            // Priority: X material takes precedence if assigned and valid
            bool useXLayout = false;

            // If X material is assigned and valid, use X layout
            if (xMat != null && IsValidXMochieMaterial(xMat))
            {
                useXLayout = true;
            }
            // Otherwise if only standard is assigned, use standard layout
            else if (standardMat != null && IsValidStandardMochieMaterial(standardMat))
            {
                useXLayout = false;
            }

            // Set the flag
            SerializedProperty useSfxXLayoutProp = mochiHandlerObject.FindProperty("useSfxXLayout");
            if (useSfxXLayoutProp != null)
            {
                useSfxXLayoutProp.boolValue = useXLayout;
            }
        }
    }
}
#endif
